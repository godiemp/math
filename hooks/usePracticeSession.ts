import { useState, useCallback } from 'react';
import { api } from '@/lib/api-client';
import { getQuestionsBySubject, getQuestionsBySkills, questions as allQuestions } from '@/lib/questions';
import type { Question } from '@/lib/types/core';

type AppState = 'selecting' | 'practicing' | 'loading' | 'analyzing-skills' | 'selecting-skills';
type Subject = 'números' | 'álgebra' | 'geometría' | 'probabilidad';
type ScaffoldingMode = 'none' | 'active' | 'skill-based';

interface Feedback {
  correct: boolean;
  message: string;
  explanation?: string;
}

// Scaffolding question type (generated by AI)
interface ScaffoldingQuestion extends Question {
  isGenerated?: boolean;
}

// Decomposed skill from AI analysis
export interface DecomposedSkill {
  id: string;
  name: string;
  description: string;
  difficulty: 'básico' | 'intermedio' | 'avanzado';
  order: number;
  completed?: boolean;
  wasCorrect?: boolean;
}

// History entry for timeline visualization
export interface ScaffoldingHistoryEntry {
  question: Question;
  depth: number;
  userAnswer: number | null;
  wasCorrect: boolean;
  feedback: Feedback | null;
  skill?: DecomposedSkill;
  timestamp: number;
}

// Stack entry for tracking scaffolding levels
interface ScaffoldingStackEntry {
  question: Question;
  depth: number;
}

// Practice options for starting with subsection
export interface PracticeOptions {
  focus: string;
  subsectionCode?: string;
  subsectionSkills?: string[];
}

// API response types
interface GeneratedQuestionResponse {
  question?: {
    id: string;
    questionLatex: string;
    options: string[];
    correctAnswer: number;
    explanation: string;
    difficulty: string;
    difficultyScore: number;
    subject: string;
    topic: string;
    targetSkills?: string[];
  };
}

interface SkillDecompositionResponse {
  skills: DecomposedSkill[];
  originalQuestion: string;
  recommendedPath: string[];
}

const MAX_SCAFFOLDING_DEPTH = 3;

function getRandomQuestion(
  focus: string,
  excludeIds: Set<string> = new Set(),
  subsectionSkills?: string[]
): Question | null {
  let pool: Question[];

  if (subsectionSkills && subsectionSkills.length > 0) {
    pool = getQuestionsBySkills(subsectionSkills);
  } else if (focus === 'surprise') {
    pool = allQuestions;
  } else {
    pool = getQuestionsBySubject(focus as Subject);
  }

  // Filter out already-seen problems
  const availablePool = pool.filter(q => !excludeIds.has(q.id));

  // If all problems seen, reset and use full pool
  const finalPool = availablePool.length > 0 ? availablePool : pool;

  if (finalPool.length === 0) return null;

  const randomIndex = Math.floor(Math.random() * finalPool.length);
  return finalPool[randomIndex];
}

/**
 * Manages adaptive practice session state: problem selection, answers, feedback, and scaffolding
 */
export function usePracticeSession() {
  // Core state
  const [state, setState] = useState<AppState>('selecting');
  const [selectedFocus, setSelectedFocus] = useState<string>('');
  const [currentProblem, setCurrentProblem] = useState<Question | null>(null);
  const [selectedAnswer, setSelectedAnswer] = useState<number | null>(null);
  const [feedback, setFeedback] = useState<Feedback | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [seenProblemIds, setSeenProblemIds] = useState<Set<string>>(new Set());

  // Subsection filtering
  const [currentSubsectionSkills, setCurrentSubsectionSkills] = useState<string[] | undefined>(undefined);
  const [currentSubsectionCode, setCurrentSubsectionCode] = useState<string | undefined>(undefined);

  // Scaffolding state
  const [scaffoldingMode, setScaffoldingMode] = useState<ScaffoldingMode>('none');
  const [scaffoldingQuestion, setScaffoldingQuestion] = useState<ScaffoldingQuestion | null>(null);
  const [originalFailedQuestion, setOriginalFailedQuestion] = useState<Question | null>(null);
  const [scaffoldingStack, setScaffoldingStack] = useState<ScaffoldingStackEntry[]>([]);
  const [scaffoldingDepth, setScaffoldingDepth] = useState(0);
  const [isGeneratingScaffolding, setIsGeneratingScaffolding] = useState(false);
  const [lastAnswerWasCorrect, setLastAnswerWasCorrect] = useState(false);

  // Skill-based scaffolding state
  const [decomposedSkills, setDecomposedSkills] = useState<DecomposedSkill[]>([]);
  const [selectedSkills, setSelectedSkills] = useState<DecomposedSkill[]>([]);
  const [currentSkillIndex, setCurrentSkillIndex] = useState(0);
  const [isDecomposingSkills, setIsDecomposingSkills] = useState(false);

  // History for timeline visualization
  const [scaffoldingHistory, setScaffoldingHistory] = useState<ScaffoldingHistoryEntry[]>([]);
  const [reviewingEntry, setReviewingEntry] = useState<ScaffoldingHistoryEntry | null>(null);

  const startPractice = useCallback((options: PracticeOptions | string) => {
    const { focus, subsectionCode, subsectionSkills } =
      typeof options === 'string' ? { focus: options, subsectionCode: undefined, subsectionSkills: undefined } : options;

    setState('loading');
    setSelectedFocus(focus);
    setCurrentSubsectionCode(subsectionCode);
    setCurrentSubsectionSkills(subsectionSkills);
    setError(null);

    // Reset all state including scaffolding
    const newSeenIds = new Set<string>();
    const problem = getRandomQuestion(focus, newSeenIds, subsectionSkills);

    if (problem) {
      newSeenIds.add(problem.id);
      setSeenProblemIds(newSeenIds);
      setCurrentProblem(problem);
      setSelectedAnswer(null);
      setFeedback(null);
      // Reset scaffolding state
      setScaffoldingMode('none');
      setScaffoldingQuestion(null);
      setOriginalFailedQuestion(null);
      setScaffoldingStack([]);
      setScaffoldingDepth(0);
      setLastAnswerWasCorrect(false);
      // Reset skill-based state
      setDecomposedSkills([]);
      setSelectedSkills([]);
      setCurrentSkillIndex(0);
      setScaffoldingHistory([]);
      setReviewingEntry(null);
      setState('practicing');
    } else {
      setError(subsectionCode
        ? 'No hay preguntas disponibles para esta subsección. Intenta con otra o practica el tema completo.'
        : 'No hay problemas disponibles para este tema');
      setState('selecting');
    }
  }, []);

  /**
   * Decompose question into skills after wrong answer
   */
  const decomposeQuestionSkills = useCallback(async (
    failedQuestion: Question,
    userAnswer: number
  ): Promise<DecomposedSkill[]> => {
    try {
      setIsDecomposingSkills(true);
      setState('analyzing-skills');

      const response = await api.post<SkillDecompositionResponse>('/api/adaptive/decompose-skills', {
        failedQuestion: {
          id: failedQuestion.id,
          questionLatex: failedQuestion.questionLatex,
          options: failedQuestion.options,
          correctAnswer: failedQuestion.correctAnswer,
          explanation: failedQuestion.explanation,
          difficulty: failedQuestion.difficulty,
          difficultyScore: failedQuestion.difficultyScore,
          subject: failedQuestion.subject,
          topic: failedQuestion.topic,
          skills: failedQuestion.skills,
        },
        userAnswer,
      });

      if (response.data?.skills) {
        const skills = response.data.skills.map(s => ({
          ...s,
          completed: false,
          wasCorrect: undefined,
        }));
        setDecomposedSkills(skills);
        setState('selecting-skills');
        return skills;
      }
      return [];
    } catch (err) {
      console.error('Failed to decompose skills:', err);
      setState('practicing');
      return [];
    } finally {
      setIsDecomposingSkills(false);
    }
  }, []);

  /**
   * Generate question for a specific skill
   */
  const generateSkillQuestion = useCallback(async (
    skill: DecomposedSkill,
    originalQuestion: Question
  ): Promise<ScaffoldingQuestion | null> => {
    try {
      setIsGeneratingScaffolding(true);

      const response = await api.post<GeneratedQuestionResponse>('/api/adaptive/generate-skill-question', {
        skill,
        originalQuestion: {
          id: originalQuestion.id,
          questionLatex: originalQuestion.questionLatex,
          options: originalQuestion.options,
          correctAnswer: originalQuestion.correctAnswer,
          explanation: originalQuestion.explanation,
          difficulty: originalQuestion.difficulty,
          difficultyScore: originalQuestion.difficultyScore,
          subject: originalQuestion.subject,
          topic: originalQuestion.topic,
          skills: originalQuestion.skills,
        },
      });

      if (response.data?.question) {
        const generated = response.data.question;
        return {
          id: generated.id,
          questionLatex: generated.questionLatex,
          options: generated.options,
          correctAnswer: generated.correctAnswer,
          explanation: generated.explanation,
          difficulty: generated.difficulty,
          difficultyScore: generated.difficultyScore,
          subject: generated.subject,
          topic: generated.topic,
          level: originalQuestion.level,
          skills: generated.targetSkills || [skill.id],
          isGenerated: true,
        } as ScaffoldingQuestion;
      }
      return null;
    } catch (err) {
      console.error('Failed to generate skill question:', err);
      return null;
    } finally {
      setIsGeneratingScaffolding(false);
    }
  }, []);

  /**
   * Request scaffolding question generation from the backend
   */
  const requestScaffoldingQuestion = useCallback(async (
    failedQuestion: Question,
    level: number
  ): Promise<ScaffoldingQuestion | null> => {
    try {
      setIsGeneratingScaffolding(true);
      const response = await api.post<GeneratedQuestionResponse>('/api/adaptive/generate-scaffolding', {
        failedQuestion: {
          id: failedQuestion.id,
          questionLatex: failedQuestion.questionLatex,
          options: failedQuestion.options,
          correctAnswer: failedQuestion.correctAnswer,
          explanation: failedQuestion.explanation,
          difficulty: failedQuestion.difficulty,
          difficultyScore: failedQuestion.difficultyScore,
          subject: failedQuestion.subject,
          topic: failedQuestion.topic,
          skills: failedQuestion.skills,
        },
        scaffoldingLevel: level,
      });

      if (response.data?.question) {
        // Convert generated question to our Question format
        const generated = response.data.question;
        return {
          id: generated.id,
          questionLatex: generated.questionLatex,
          options: generated.options,
          correctAnswer: generated.correctAnswer,
          explanation: generated.explanation,
          difficulty: generated.difficulty,
          difficultyScore: generated.difficultyScore,
          subject: generated.subject,
          topic: generated.topic,
          level: failedQuestion.level,
          skills: generated.targetSkills || failedQuestion.skills,
          isGenerated: true,
        } as ScaffoldingQuestion;
      }
      return null;
    } catch (err) {
      console.error('Failed to generate scaffolding question:', err);
      return null;
    } finally {
      setIsGeneratingScaffolding(false);
    }
  }, []);

  /**
   * Request a similar question to the original (for returning after scaffolding)
   */
  const requestSimilarQuestion = useCallback(async (
    originalQuestion: Question
  ): Promise<ScaffoldingQuestion | null> => {
    try {
      setIsGeneratingScaffolding(true);
      const response = await api.post<GeneratedQuestionResponse>('/api/adaptive/generate-similar', {
        originalQuestion: {
          id: originalQuestion.id,
          questionLatex: originalQuestion.questionLatex,
          options: originalQuestion.options,
          correctAnswer: originalQuestion.correctAnswer,
          explanation: originalQuestion.explanation,
          difficulty: originalQuestion.difficulty,
          difficultyScore: originalQuestion.difficultyScore,
          subject: originalQuestion.subject,
          topic: originalQuestion.topic,
          skills: originalQuestion.skills,
        },
      });

      if (response.data?.question) {
        const generated = response.data.question;
        return {
          id: generated.id,
          questionLatex: generated.questionLatex,
          options: generated.options,
          correctAnswer: generated.correctAnswer,
          explanation: generated.explanation,
          difficulty: generated.difficulty,
          difficultyScore: generated.difficultyScore,
          subject: generated.subject,
          topic: generated.topic,
          level: originalQuestion.level,
          skills: generated.targetSkills || originalQuestion.skills,
          isGenerated: true,
        } as ScaffoldingQuestion;
      }
      return null;
    } catch (err) {
      console.error('Failed to generate similar question:', err);
      return null;
    } finally {
      setIsGeneratingScaffolding(false);
    }
  }, []);

  const submitAnswer = useCallback(async (hintUsed: boolean) => {
    if (!currentProblem || selectedAnswer === null) return;

    const correct = selectedAnswer === currentProblem.correctAnswer;
    setLastAnswerWasCorrect(correct);

    const currentFeedback: Feedback = {
      correct,
      message: correct ? '¡Muy bien!' : 'Revisa la explicación e intenta el siguiente.',
      explanation: correct ? undefined : currentProblem.explanation,
    };
    setFeedback(currentFeedback);

    // Add to history for timeline
    const historyEntry: ScaffoldingHistoryEntry = {
      question: currentProblem,
      depth: scaffoldingDepth,
      userAnswer: selectedAnswer,
      wasCorrect: correct,
      feedback: currentFeedback,
      skill: selectedSkills[currentSkillIndex],
      timestamp: Date.now(),
    };

    // Only add to history if we're in scaffolding mode
    if (scaffoldingMode !== 'none') {
      setScaffoldingHistory(prev => [...prev, historyEntry]);

      // Update skill completion status
      if (scaffoldingMode === 'skill-based' && selectedSkills[currentSkillIndex]) {
        setSelectedSkills(prev => prev.map((s, i) =>
          i === currentSkillIndex ? { ...s, completed: true, wasCorrect: correct } : s
        ));
      }
    }

    // Save attempt to backend (fire-and-forget)
    try {
      await api.post('/api/adaptive/attempt', {
        questionId: currentProblem.id,
        subject: currentProblem.subject,
        topic: currentProblem.topic || currentProblem.subject,
        difficulty: currentProblem.difficulty,
        userAnswer: selectedAnswer,
        correctAnswer: currentProblem.correctAnswer,
        isCorrect: correct,
        skills: currentProblem.skills || [],
        hintUsed,
        question: currentProblem.questionLatex,
        options: currentProblem.options,
        explanation: currentProblem.explanation,
      });
    } catch (err) {
      console.error('Failed to save attempt:', err);
    }

    // Handle scaffolding logic for incorrect answers
    if (!correct && scaffoldingDepth === 0 && scaffoldingMode === 'none') {
      // First failure - store original question for potential scaffolding
      setOriginalFailedQuestion(currentProblem);
    }
  }, [currentProblem, selectedAnswer, scaffoldingDepth, scaffoldingMode, selectedSkills, currentSkillIndex]);

  /**
   * Start skill-based scaffolding with selected skills
   */
  const startSkillBasedScaffolding = useCallback(async (skills: DecomposedSkill[]) => {
    if (!originalFailedQuestion || skills.length === 0) return;

    setSelectedSkills(skills);
    setCurrentSkillIndex(0);
    setScaffoldingMode('skill-based');
    setScaffoldingDepth(1);

    // Add original failed question to history
    setScaffoldingHistory([{
      question: originalFailedQuestion,
      depth: 0,
      userAnswer: selectedAnswer,
      wasCorrect: false,
      feedback,
      timestamp: Date.now(),
    }]);

    // Generate first skill question
    setState('loading');
    const firstSkill = skills[0];
    const skillQuestion = await generateSkillQuestion(firstSkill, originalFailedQuestion);

    if (skillQuestion) {
      setCurrentProblem(skillQuestion);
      setSelectedAnswer(null);
      setFeedback(null);
      setState('practicing');
    } else {
      // Fallback to original scaffolding if skill question fails
      setError('No se pudo generar la pregunta. Intenta de nuevo.');
      setState('practicing');
    }
  }, [originalFailedQuestion, selectedAnswer, feedback, generateSkillQuestion]);

  /**
   * Proceed to the scaffolding question - generates on-demand to save tokens
   */
  const proceedToScaffolding = useCallback(async () => {
    if (!currentProblem || isGeneratingScaffolding) return;
    if (scaffoldingDepth >= MAX_SCAFFOLDING_DEPTH) return;

    // If we have an original failed question and no skill decomposition yet, do that first
    if (scaffoldingDepth === 0 && originalFailedQuestion && selectedAnswer !== null) {
      await decomposeQuestionSkills(originalFailedQuestion, selectedAnswer);
      return;
    }

    // Generate scaffolding question on-demand
    const nextLevel = scaffoldingDepth + 1;
    const scaffolding = await requestScaffoldingQuestion(currentProblem, nextLevel);

    if (!scaffolding) {
      // Generation failed - just move to next problem
      console.error('Failed to generate scaffolding question');
      return;
    }

    // Push current problem to stack
    setScaffoldingStack(prev => [...prev, { question: currentProblem, depth: scaffoldingDepth }]);

    // Increment depth
    setScaffoldingDepth(nextLevel);

    // Set scaffolding as current problem
    setCurrentProblem(scaffolding);
    setScaffoldingMode('active');
    setScaffoldingQuestion(null);
    setSelectedAnswer(null);
    setFeedback(null);
  }, [currentProblem, scaffoldingDepth, isGeneratingScaffolding, requestScaffoldingQuestion, originalFailedQuestion, selectedAnswer, decomposeQuestionSkills]);

  /**
   * Skip skill selection and go to next problem
   */
  const skipSkillSelection = useCallback(() => {
    setState('practicing');
    setDecomposedSkills([]);
  }, []);

  const nextProblem = useCallback(async () => {
    // Prevent multiple clicks while generating
    if (isGeneratingScaffolding) return;

    // If in skill-based scaffolding mode
    if (scaffoldingMode === 'skill-based' && lastAnswerWasCorrect) {
      const nextSkillIndex = currentSkillIndex + 1;

      if (nextSkillIndex < selectedSkills.length) {
        // Move to next skill
        setCurrentSkillIndex(nextSkillIndex);
        setState('loading');

        const nextSkill = selectedSkills[nextSkillIndex];
        const skillQuestion = await generateSkillQuestion(nextSkill, originalFailedQuestion!);

        if (skillQuestion) {
          setCurrentProblem(skillQuestion);
          setScaffoldingDepth(nextSkillIndex + 1);
        } else {
          // Fallback to random question
          const problem = getRandomQuestion(selectedFocus, seenProblemIds, currentSubsectionSkills);
          if (problem) {
            setSeenProblemIds(prev => new Set(prev).add(problem.id));
            setCurrentProblem(problem);
          }
          // Reset scaffolding
          setScaffoldingMode('none');
          setSelectedSkills([]);
          setCurrentSkillIndex(0);
          setScaffoldingDepth(0);
        }

        setSelectedAnswer(null);
        setFeedback(null);
        setState('practicing');
        return;
      } else {
        // Completed all skills - generate similar question to original
        if (originalFailedQuestion) {
          const similar = await requestSimilarQuestion(originalFailedQuestion);
          if (similar) {
            setCurrentProblem(similar);
            setSeenProblemIds(prev => new Set(prev).add(similar.id));
          } else {
            const problem = getRandomQuestion(selectedFocus, seenProblemIds, currentSubsectionSkills);
            if (problem) {
              setSeenProblemIds(prev => new Set(prev).add(problem.id));
              setCurrentProblem(problem);
            }
          }
        }

        // Reset all scaffolding state
        setScaffoldingMode('none');
        setSelectedSkills([]);
        setCurrentSkillIndex(0);
        setScaffoldingDepth(0);
        setOriginalFailedQuestion(null);
        setScaffoldingHistory([]);
        setSelectedAnswer(null);
        setFeedback(null);
        setLastAnswerWasCorrect(false);
        return;
      }
    }

    // If in regular scaffolding mode and last answer was correct
    if (scaffoldingMode === 'active' && lastAnswerWasCorrect) {
      if (scaffoldingDepth === 1 && originalFailedQuestion) {
        // At level 1, generate a similar question to the original
        const similar = await requestSimilarQuestion(originalFailedQuestion);
        if (similar) {
          setCurrentProblem(similar);
          setSeenProblemIds(prev => new Set(prev).add(similar.id));
        } else {
          // Fallback to a random question if generation fails
          const problem = getRandomQuestion(selectedFocus, seenProblemIds, currentSubsectionSkills);
          if (problem) {
            setSeenProblemIds(prev => new Set(prev).add(problem.id));
            setCurrentProblem(problem);
          }
        }
        // Reset scaffolding state completely
        setScaffoldingMode('none');
        setScaffoldingStack([]);
        setScaffoldingDepth(0);
        setOriginalFailedQuestion(null);
        setScaffoldingHistory([]);
      } else if (scaffoldingDepth > 1) {
        // Pop from stack - go back to previous scaffolding level
        const newStack = [...scaffoldingStack];
        const previous = newStack.pop();
        if (previous) {
          setScaffoldingStack(newStack);
          setScaffoldingDepth(scaffoldingDepth - 1);
          setCurrentProblem(previous.question);
        }
      }
    } else {
      // Normal flow or failed at max depth - get new random question
      const problem = getRandomQuestion(selectedFocus, seenProblemIds, currentSubsectionSkills);
      if (problem) {
        setSeenProblemIds(prev => new Set(prev).add(problem.id));
        setCurrentProblem(problem);
      }
      // Reset scaffolding state
      setScaffoldingMode('none');
      setScaffoldingStack([]);
      setScaffoldingDepth(0);
      setOriginalFailedQuestion(null);
      setScaffoldingHistory([]);
    }

    setSelectedAnswer(null);
    setFeedback(null);
    setScaffoldingQuestion(null);
    setLastAnswerWasCorrect(false);
  }, [
    isGeneratingScaffolding,
    scaffoldingMode,
    lastAnswerWasCorrect,
    scaffoldingDepth,
    originalFailedQuestion,
    scaffoldingStack,
    selectedFocus,
    seenProblemIds,
    currentSubsectionSkills,
    requestSimilarQuestion,
    selectedSkills,
    currentSkillIndex,
    generateSkillQuestion,
  ]);

  const changeTopic = useCallback(() => {
    setState('selecting');
    setCurrentProblem(null);
    setSelectedAnswer(null);
    setFeedback(null);
    setError(null);
    setSeenProblemIds(new Set());
    setCurrentSubsectionCode(undefined);
    setCurrentSubsectionSkills(undefined);
    // Reset scaffolding state
    setScaffoldingMode('none');
    setScaffoldingQuestion(null);
    setOriginalFailedQuestion(null);
    setScaffoldingStack([]);
    setScaffoldingDepth(0);
    setLastAnswerWasCorrect(false);
    // Reset skill-based state
    setDecomposedSkills([]);
    setSelectedSkills([]);
    setCurrentSkillIndex(0);
    setScaffoldingHistory([]);
    setReviewingEntry(null);
  }, []);

  return {
    // Core state
    state,
    selectedFocus,
    currentProblem,
    selectedAnswer,
    feedback,
    error,
    // Subsection state
    currentSubsectionCode,
    currentSubsectionSkills,
    // Scaffolding state
    scaffoldingMode,
    scaffoldingQuestion,
    scaffoldingDepth,
    isGeneratingScaffolding,
    maxScaffoldingDepth: MAX_SCAFFOLDING_DEPTH,
    // Skill-based scaffolding state
    decomposedSkills,
    selectedSkills,
    currentSkillIndex,
    isDecomposingSkills,
    // History for timeline
    scaffoldingHistory,
    reviewingEntry,
    setReviewingEntry,
    // Actions
    startPractice,
    setSelectedAnswer,
    submitAnswer,
    nextProblem,
    changeTopic,
    proceedToScaffolding,
    startSkillBasedScaffolding,
    skipSkillSelection,
  };
}
