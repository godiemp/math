import { useState, useCallback } from 'react';
import { api } from '@/lib/api-client';
import { getQuestionsBySubject, questions as allQuestions } from '@/lib/questions';
import type { Question } from '@/lib/types/core';

type AppState = 'selecting' | 'practicing' | 'loading';
type Subject = 'números' | 'álgebra' | 'geometría' | 'probabilidad';
type ScaffoldingMode = 'none' | 'active';

interface Feedback {
  correct: boolean;
  message: string;
  explanation?: string;
}

// Scaffolding question type (generated by AI)
interface ScaffoldingQuestion extends Question {
  isGenerated?: boolean;
}

// Stack entry for tracking scaffolding levels
interface ScaffoldingStackEntry {
  question: Question;
  depth: number;
}

// API response types
interface GeneratedQuestionResponse {
  question?: {
    id: string;
    questionLatex: string;
    options: string[];
    correctAnswer: number;
    explanation: string;
    difficulty: string;
    difficultyScore: number;
    subject: string;
    topic: string;
    targetSkills?: string[];
  };
}

const MAX_SCAFFOLDING_DEPTH = 3;

function getRandomQuestion(focus: string, excludeIds: Set<string> = new Set()): Question | null {
  let pool: Question[];

  if (focus === 'surprise') {
    pool = allQuestions;
  } else {
    pool = getQuestionsBySubject(focus as Subject);
  }

  // Filter out already-seen problems
  const availablePool = pool.filter(q => !excludeIds.has(q.id));

  // If all problems seen, reset and use full pool
  const finalPool = availablePool.length > 0 ? availablePool : pool;

  if (finalPool.length === 0) return null;

  const randomIndex = Math.floor(Math.random() * finalPool.length);
  return finalPool[randomIndex];
}

/**
 * Manages adaptive practice session state: problem selection, answers, feedback, and scaffolding
 */
export function usePracticeSession() {
  // Core state
  const [state, setState] = useState<AppState>('selecting');
  const [selectedFocus, setSelectedFocus] = useState<string>('');
  const [currentProblem, setCurrentProblem] = useState<Question | null>(null);
  const [selectedAnswer, setSelectedAnswer] = useState<number | null>(null);
  const [feedback, setFeedback] = useState<Feedback | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [seenProblemIds, setSeenProblemIds] = useState<Set<string>>(new Set());

  // Scaffolding state
  const [scaffoldingMode, setScaffoldingMode] = useState<ScaffoldingMode>('none');
  const [scaffoldingQuestion, setScaffoldingQuestion] = useState<ScaffoldingQuestion | null>(null);
  const [originalFailedQuestion, setOriginalFailedQuestion] = useState<Question | null>(null);
  const [scaffoldingStack, setScaffoldingStack] = useState<ScaffoldingStackEntry[]>([]);
  const [scaffoldingDepth, setScaffoldingDepth] = useState(0);
  const [isGeneratingScaffolding, setIsGeneratingScaffolding] = useState(false);
  const [lastAnswerWasCorrect, setLastAnswerWasCorrect] = useState(false);

  const startPractice = useCallback((focus: string) => {
    setState('loading');
    setSelectedFocus(focus);
    setError(null);

    // Reset all state including scaffolding
    const newSeenIds = new Set<string>();
    const problem = getRandomQuestion(focus, newSeenIds);

    if (problem) {
      newSeenIds.add(problem.id);
      setSeenProblemIds(newSeenIds);
      setCurrentProblem(problem);
      setSelectedAnswer(null);
      setFeedback(null);
      // Reset scaffolding state
      setScaffoldingMode('none');
      setScaffoldingQuestion(null);
      setOriginalFailedQuestion(null);
      setScaffoldingStack([]);
      setScaffoldingDepth(0);
      setLastAnswerWasCorrect(false);
      setState('practicing');
    } else {
      setError('No hay problemas disponibles para este tema');
      setState('selecting');
    }
  }, []);

  /**
   * Request scaffolding question generation from the backend
   */
  const requestScaffoldingQuestion = useCallback(async (
    failedQuestion: Question,
    level: number
  ): Promise<ScaffoldingQuestion | null> => {
    try {
      setIsGeneratingScaffolding(true);
      const response = await api.post<GeneratedQuestionResponse>('/api/adaptive/generate-scaffolding', {
        failedQuestion: {
          id: failedQuestion.id,
          questionLatex: failedQuestion.questionLatex,
          options: failedQuestion.options,
          correctAnswer: failedQuestion.correctAnswer,
          explanation: failedQuestion.explanation,
          difficulty: failedQuestion.difficulty,
          difficultyScore: failedQuestion.difficultyScore,
          subject: failedQuestion.subject,
          topic: failedQuestion.topic,
          skills: failedQuestion.skills,
        },
        scaffoldingLevel: level,
      });

      if (response.data.question) {
        // Convert generated question to our Question format
        const generated = response.data.question;
        return {
          id: generated.id,
          questionLatex: generated.questionLatex,
          options: generated.options,
          correctAnswer: generated.correctAnswer,
          explanation: generated.explanation,
          difficulty: generated.difficulty,
          difficultyScore: generated.difficultyScore,
          subject: generated.subject,
          topic: generated.topic,
          level: failedQuestion.level,
          skills: generated.targetSkills || failedQuestion.skills,
          isGenerated: true,
        } as ScaffoldingQuestion;
      }
      return null;
    } catch (err) {
      console.error('Failed to generate scaffolding question:', err);
      return null;
    } finally {
      setIsGeneratingScaffolding(false);
    }
  }, []);

  /**
   * Request a similar question to the original (for returning after scaffolding)
   */
  const requestSimilarQuestion = useCallback(async (
    originalQuestion: Question
  ): Promise<ScaffoldingQuestion | null> => {
    try {
      setIsGeneratingScaffolding(true);
      const response = await api.post<GeneratedQuestionResponse>('/api/adaptive/generate-similar', {
        originalQuestion: {
          id: originalQuestion.id,
          questionLatex: originalQuestion.questionLatex,
          options: originalQuestion.options,
          correctAnswer: originalQuestion.correctAnswer,
          explanation: originalQuestion.explanation,
          difficulty: originalQuestion.difficulty,
          difficultyScore: originalQuestion.difficultyScore,
          subject: originalQuestion.subject,
          topic: originalQuestion.topic,
          skills: originalQuestion.skills,
        },
      });

      if (response.data.question) {
        const generated = response.data.question;
        return {
          id: generated.id,
          questionLatex: generated.questionLatex,
          options: generated.options,
          correctAnswer: generated.correctAnswer,
          explanation: generated.explanation,
          difficulty: generated.difficulty,
          difficultyScore: generated.difficultyScore,
          subject: generated.subject,
          topic: generated.topic,
          level: originalQuestion.level,
          skills: generated.targetSkills || originalQuestion.skills,
          isGenerated: true,
        } as ScaffoldingQuestion;
      }
      return null;
    } catch (err) {
      console.error('Failed to generate similar question:', err);
      return null;
    } finally {
      setIsGeneratingScaffolding(false);
    }
  }, []);

  const submitAnswer = useCallback(async (hintUsed: boolean) => {
    if (!currentProblem || selectedAnswer === null) return;

    const correct = selectedAnswer === currentProblem.correctAnswer;
    setLastAnswerWasCorrect(correct);

    setFeedback({
      correct,
      message: correct ? '¡Muy bien!' : 'Revisa la explicación e intenta el siguiente.',
      explanation: correct ? undefined : currentProblem.explanation,
    });

    // Save attempt to backend (fire-and-forget)
    try {
      await api.post('/api/adaptive/attempt', {
        questionId: currentProblem.id,
        subject: currentProblem.subject,
        topic: currentProblem.topic || currentProblem.subject,
        difficulty: currentProblem.difficulty,
        userAnswer: selectedAnswer,
        correctAnswer: currentProblem.correctAnswer,
        isCorrect: correct,
        skills: currentProblem.skills || [],
        hintUsed,
        question: currentProblem.questionLatex,
        options: currentProblem.options,
        explanation: currentProblem.explanation,
      });
    } catch (err) {
      console.error('Failed to save attempt:', err);
    }

    // Handle scaffolding logic for incorrect answers
    if (!correct) {
      if (scaffoldingDepth === 0) {
        // First failure - store original and prepare scaffolding level 1
        setOriginalFailedQuestion(currentProblem);
        const scaffolding = await requestScaffoldingQuestion(currentProblem, 1);
        setScaffoldingQuestion(scaffolding);
      } else if (scaffoldingDepth < MAX_SCAFFOLDING_DEPTH) {
        // Failed during scaffolding - prepare deeper level
        const nextLevel = scaffoldingDepth + 1;
        const scaffolding = await requestScaffoldingQuestion(currentProblem, nextLevel);
        setScaffoldingQuestion(scaffolding);
      } else {
        // Max depth reached - no more scaffolding available
        setScaffoldingQuestion(null);
      }
    }
  }, [currentProblem, selectedAnswer, scaffoldingDepth, requestScaffoldingQuestion]);

  /**
   * Proceed to the scaffolding question
   */
  const proceedToScaffolding = useCallback(() => {
    if (!scaffoldingQuestion || !currentProblem) return;

    // Push current problem to stack
    setScaffoldingStack(prev => [...prev, { question: currentProblem, depth: scaffoldingDepth }]);

    // Increment depth
    const newDepth = scaffoldingDepth + 1;
    setScaffoldingDepth(newDepth);

    // Set scaffolding as current problem
    setCurrentProblem(scaffoldingQuestion);
    setScaffoldingMode('active');
    setScaffoldingQuestion(null);
    setSelectedAnswer(null);
    setFeedback(null);
  }, [scaffoldingQuestion, currentProblem, scaffoldingDepth]);

  const nextProblem = useCallback(async () => {
    // If in scaffolding mode and last answer was correct
    if (scaffoldingMode === 'active' && lastAnswerWasCorrect) {
      if (scaffoldingDepth === 1 && originalFailedQuestion) {
        // At level 1, generate a similar question to the original
        const similar = await requestSimilarQuestion(originalFailedQuestion);
        if (similar) {
          setCurrentProblem(similar);
          setSeenProblemIds(prev => new Set(prev).add(similar.id));
        } else {
          // Fallback to a random question if generation fails
          const problem = getRandomQuestion(selectedFocus, seenProblemIds);
          if (problem) {
            setSeenProblemIds(prev => new Set(prev).add(problem.id));
            setCurrentProblem(problem);
          }
        }
        // Reset scaffolding state completely
        setScaffoldingMode('none');
        setScaffoldingStack([]);
        setScaffoldingDepth(0);
        setOriginalFailedQuestion(null);
      } else if (scaffoldingDepth > 1) {
        // Pop from stack - go back to previous scaffolding level
        const newStack = [...scaffoldingStack];
        const previous = newStack.pop();
        if (previous) {
          setScaffoldingStack(newStack);
          setScaffoldingDepth(scaffoldingDepth - 1);
          setCurrentProblem(previous.question);
        }
      }
    } else {
      // Normal flow or failed at max depth - get new random question
      const problem = getRandomQuestion(selectedFocus, seenProblemIds);
      if (problem) {
        setSeenProblemIds(prev => new Set(prev).add(problem.id));
        setCurrentProblem(problem);
      }
      // Reset scaffolding state
      setScaffoldingMode('none');
      setScaffoldingStack([]);
      setScaffoldingDepth(0);
      setOriginalFailedQuestion(null);
    }

    setSelectedAnswer(null);
    setFeedback(null);
    setScaffoldingQuestion(null);
    setLastAnswerWasCorrect(false);
  }, [
    scaffoldingMode,
    lastAnswerWasCorrect,
    scaffoldingDepth,
    originalFailedQuestion,
    scaffoldingStack,
    selectedFocus,
    seenProblemIds,
    requestSimilarQuestion,
  ]);

  const changeTopic = useCallback(() => {
    setState('selecting');
    setCurrentProblem(null);
    setSelectedAnswer(null);
    setFeedback(null);
    setError(null);
    setSeenProblemIds(new Set());
    // Reset scaffolding state
    setScaffoldingMode('none');
    setScaffoldingQuestion(null);
    setOriginalFailedQuestion(null);
    setScaffoldingStack([]);
    setScaffoldingDepth(0);
    setLastAnswerWasCorrect(false);
  }, []);

  return {
    // Core state
    state,
    selectedFocus,
    currentProblem,
    selectedAnswer,
    feedback,
    error,
    // Scaffolding state
    scaffoldingMode,
    scaffoldingQuestion,
    scaffoldingDepth,
    isGeneratingScaffolding,
    maxScaffoldingDepth: MAX_SCAFFOLDING_DEPTH,
    // Actions
    startPractice,
    setSelectedAnswer,
    submitAnswer,
    nextProblem,
    changeTopic,
    proceedToScaffolding,
  };
}
